import math


def get_link_v(v, D):  # перебираем матрицу смешности и если вес >0 то возвращаем номер вершины
    for i, weight in enumerate(D[v]):
        if weight > 0:
            yield i


def arg_min(T, S):
    amin = -1
    m = max(T)  # максимальное значение Т
    for i, t in enumerate(T):
        if t < m and i not in S:  # Находим минимальное значение для вершин которые еще не рассмотрели
            m = t
            amin = i
    return amin


D = ((0, 2, 0, 3, 0, 0),   # задаем в матрице растояние, вес
     (2, 0, 3, 0, 0, 0),   # от одной вершины с другой
     (0, 3, 0, 2, 7, 6),   # в зависимости их отношения к друг другу(есть или нет связи)
     (1, 0, 2, 0, 0, 0),
     (0, 0, 7, 0, 0, 0),
     (0, 0, 9, 0, 0, 0))

N = len(D)  # число вершин в графе
T = [math.inf] * N  # последняя строка таблицы
v = 0  # стартовая вершина(номерация с 0)
S = {v}  # просмотренные вершины
T[v] = 0  # 0 вес для стартовой вершины
while v != -1:  # Цикл, пока не пересмотрели все вершины
    for j in get_link_v(v, D):  # перебираем все связаные вершины с вершиной V
        if j not in S:          # если вершина еще не просмотрена
            w = T[v] + D[v][j]  # начальный вес вершины + вес дуги
            if w < T[j]:
                T[j] = w
    v = arg_min(T, S)  # выбираем следующий узел с наименьшим весом
    if v > 0:  # выбрана очередная вершина
        S.add(v)  # добовляем новую вершину в рассмотрение

print(T)
